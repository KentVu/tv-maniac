import com.thomaskioko.tvmaniac.db.Id;
import com.thomaskioko.tvmaniac.db.ShowId;
import kotlin.String;
import kotlin.collections.List;

CREATE TABLE show(
    id INTEGER AS Id<ShowId> NOT NULL PRIMARY KEY,
    tmdb_id INTEGER,
    title TEXT NOT NULL,
    overview TEXT NOT NULL,
    language TEXT,
    year TEXT NOT NULL,
    rating REAL NOT NULL,
    status TEXT NOT NULL,
    runtime INTEGER NOT NULL,
    votes INTEGER NOT NULL,
    aired_episodes INTEGER DEFAULT NULL,
    genres TEXT AS List<String> NOT NULL
);

-- indices

CREATE UNIQUE INDEX IF NOT EXISTS `index_shows_show_id` ON `show` (`id`);

-- queries

insertOrReplace:
INSERT OR REPLACE INTO show(
    id,
    tmdb_id,
    title,
    overview,
    language,
    year,
    votes,
    runtime,
    rating,
    genres,
    status
)
VALUES(?,?,?,?,?,?,?,?,?,?,?);

showById:
SELECT
    show.id,
    show.tmdb_id ,
    show.title,
    show.overview,
    show.language,
    show.year,
    show.rating,
    show.votes,
    show.status,
    show.runtime,
    show.genres,
    show.aired_episodes,
    show_image.poster_url,
    show_image.backdrop_url,
    CASE WHEN watchlist.id IS NOT NULL THEN 1 ELSE 0 END AS in_watchlist
FROM
    show
LEFT OUTER JOIN
    show_image ON show_image.id = show.id
LEFT OUTER JOIN
    watchlist ON show.id = watchlist.id
WHERE
    show.id = ?;

shows:
SELECT
    show.id,
    show.tmdb_id ,
    show.title,
    show.overview,
    show.language,
    show.year,
    show.rating,
    show.votes,
    show.status,
    show.runtime,
    show.genres,
    show.aired_episodes,
    show_image.poster_url,
    show_image.backdrop_url,
    show_category.category_id
FROM
    show
JOIN
    show_category ON show_category.id = show.id
LEFT OUTER JOIN
    show_image ON show_image.id = show.id
ORDER BY
    show.rating, show.year DESC;

deleteAll:
DELETE FROM show;